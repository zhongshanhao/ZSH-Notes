项目背景

图像围栏网站后端代码编写和维护

如写接口返回用户信息、摄像头信息、抓拍信息、处理用户的请求

如用户上传一张图片，去掉抽特征服务

架构

前后端分离、后端springboot、spring

resource-manager：包含资源管理和权限管理两个模块；其中参与了资源管理模块的设计与实现，实现了一个线程安全、缓存和持久化、条件查询和包含索引查询加速的底层资源库。

图片存储服务：kv

静态库的meta在mongo，动态库在es，这俩都是只存个uri，图片本身在kv

LruCache机制

背景：网站上经常展示一些摄像头抓拍的图片、用户人像库的图片，而这些图片存储在数据库中，每次获取图片需要从远端数据库中拿，这样延迟较高，限制了网站的qps

为了能够有效提高图像围栏的性能，引入了一种带有清退机制的缓存结构LruCache(Least Recently Used Cache)，在目前的系统中，使用LruCache + 键值存储数据库的机制将远端数据变为本地缓存数据，不仅能够降低平均获取信息的耗时，而且通过一定的清退机制，也可以维持服务内存占用在安全区间。

LruCache内部维护一个双向链表和一个映射表。链表按照使用顺序存储缓存数据，越早使用的数据越靠近链表尾部，越晚使用的数据越靠近链表头部；映射表通过Key-Value结构，提供高效的查找操作，通过键值可以判断某一数据是否缓存，如果缓存直接获取缓存数据所属的链表节点，进一步获取缓存数据。LruCache结构图如下所示，上半部分是双向链表，下半部分是映射表（不一定有序）。双向链表中value_1所处位置为链表头部，value_N所处位置为链表尾部。

![51554b90bd36dfa46aa1c2338cfbe3b56921](D:\_temp\网络图片\51554b90bd36dfa46aa1c2338cfbe3b56921.png)

接口设计

```Java
interface LruCache<T> {
    T get(String id);
    
    boolean put(String id, T resource);
}
```

实现

```java
public class LruCacheImpl<T> implements LruCache<T> {
    
    @Override
    T get(String id) {
        
    }
}
```

```get()```操作，取数据时，先判断数据在不在缓存中

- 不在就到数据库中取出数据，插入到缓存（链表头）中
- 在就将节点移动到链表头中

```put()```操作，放数据库，然后更新缓存

线程安全的LruCache在读写操作中，全部使用锁做临界区保护，确保缓存使用是线程安全的。

> get和put的时候都得加锁保证线程安全问题，在缓存不命中的情况下，需要先加锁，并到数据库中取数据，然后在写cache，比不用cache更慢。因此，使用LruCache的前提是保证缓存的命中率

[参考文章](https://tech.meituan.com/2018/12/20/lrucache-practice-dsp.html)

缓存一致性