定义：

分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。

特点

- 分布性

- 对等性

- 并发性

- 缺乏全局时钟

- 故障总会发生

挑战

- 通信异常
- 网络分区
- 三态
- 节点故障

从acid到cap/base

cap定理	

一个分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容错性（P：Partition tolerance）这三个基本需求，最多只能满足其中两项。

一致性

一致性是指数据在多个副本之间是否能够保持一致的特性。在一致性的需求下，一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一致的状态。

强一致性：分布式系统中，如果能够做到针对一个数据项的更新操作执行成功后，所有用户都可以读取到其最新的值。

弱一致性：最终一致性

可用性

指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间（因各个场景而异）内返回结果。

分区容错性

指的是分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。

BASE理论

BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写，BASE是对CAP中一致性和可用性权衡的结果，其核心思想是即使无法做到强一致性，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。

- 基本可用
- 弱状态
- 最终一致性

# 一致性协议

## 2PC

Two-Phase Commit

阶段一：提交事务请求

- 事务询问：协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应
- 执行事务：各参与者节点执行事务操作，并将Undo和Redo信息记入事务日志中
- 各参与者向协调者反馈事务询问的响应：如果参与者成功执行了事务操作，那么就反馈给协调者Yes响应，否者就返回No

阶段二：执行事务提交

协调者根据各参与者的反馈情况决定最终是否可以进行事务提交操作，有两种可能

执行事务提交

加入协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务提交，步骤如下

- 发送提交请求：协调者向所有参与者节点发出Commit请求
- 事务提交：参与者接收到Commit请求后，会正式执行事务提交操作，并释放事务执行期间占用的资源。
- 反馈事务提交结果：参与者完成事务提交之后，向协调者发送Ack消息。
- 完成事务

中断事务

假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚接收到所有参与者的反馈响应，那么会中断事务

- 发送回滚请求：协调者向所有参与者节点发出Rollback请求
- 事务回滚：参与者会利用阶段一记录的Undo信息来执行事务的回滚操作，并释放事务执行期间占用的资源。
- 反馈事务回滚结果：参与者在完成事务回滚之后，向协调者发送Ack消息。
- 中断事务

优点：原理简单、实现方便

缺点：同步阻塞、单点问题、脑裂、数据不一致、太过保守

同步阻塞：在事务提交的过程中，所有参与该事务操作的逻辑都处于阻塞状态，限制了分布式系统的性能

单点问题：如果协调者出现问题，那么整个二阶段提交流程将无法运转

数据不一致：在执行事务提交的时候，当协调者向所有的参与者发出Commit请求之后，发生了局部网络异常或者是协调者在尚未发送完Commit请求之前自身发生了崩溃，导致最终只有部分参与者收到Commit请求，这些参与者将会提交事务，于是整个分布式系统就会出现数据不一致现象。

## 3PC

是二阶段提交协议的改进，将提交事务请求一分为二

阶段一：CanCommit

阶段二：PreCommit

阶段三：doCommit

![3](http://www.hollischuang.com/wp-content/uploads/2015/12/3.png)

阶段三，可能会出现两种故障

- 协调者出现问题
- 协调者和参与者之间的网络出现故障

这样的情况参与者都会在等待超时之后，继续进行事务提交

在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。（其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了PreCommit请求，那么协调者产生PreCommit请求的前提条件是他在第二阶段开始之前，收到所有参与者的CanCommit响应都是Yes。（一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了）所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大。 ）

优点：降低参与者的阻塞范围，并且能够在出现单点故障之后继续达成一致

缺点：在二阶段，参与者接受到preCommit消息后，如果网络出现分区，此时协调者所在的节点和参与者无法进行正常的网络通信，在这种情况下，一旦超时时间到了，参与者依然会进行事务提交，这必然会导致数据不一致性。

## Paxos	

二阶段和三阶段提交协议不能完全解决数据一致性问题，Paxos是一种基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一。

## Raft

raft简介

Raft 就是用来管理复制日志（replicated log）的一致性协议。一致性算法允许多台机器作为一个集群协同工作，并且在其中的某几台机器出故障时集群仍然能正常工作。它是如何做到的？

复制状态机

复制状态机就是说多个不同的机器，运行着相同的代码，如果每个机器处理的输入序列一样，那么它们的输出序列也一样，那么，在其中一个机器宕机时，那么其他机器就可以代替该机器处理请求，一致性算法就是在复制状态机的背景下产生的。

复制状态机通常使用复制日志实现，如图 1 所示。每个服务器存储一个包含一系列命令的日志，其状态机按顺序执行日志中的命令。 每个日志中命令都相同并且顺序也一样，因此每个状态机处理相同的命令序列。 这样就能得到相同的状态和相同的输出序列。

<img src="D:\workplace\temp\iamge\复制状态机.png" alt="复制状态机" style="zoom:80%;" />

raft的简单工作机制

[gif图片演示](http://thesecretlivesofdata.com/raft/)

每个节点可以有三个状态

- Follower
- Candidate
- Leader

有个timeout属性，如果follower没有在timeout时间内从leader处得到消息，那么它将会成为candidate。timeout被随机为150-300ms。

Term，当前是第几任leader，如果集群内出现了多个leader，那么Term最大的leader是真正的leader

leader 选举

一开始所有节点都处于follower状态，如果follower没有在timeout时间内从leader处得到消息，那么它将会成为candidate，candidate给其他节点发出投票请求，节点会选择最先到达的投票请求，把它的票投给该请求的发起者，一个节点只能投一次票，如果

- 其中一个candidate得到了超过半数的投票，那么该candidate将会成为leader，并持续向follower发送心跳
- 其中两个candidate得到了相同的票数，那么两个candidate将重新计一个timeout

如果leader挂了，那么节点在timeout时间之后，会成为candidate，竞选leader，收到半数的投票的节点将会成为下一任leader

日志复制

当leader产生，所有的对系统改变的请求将会通过leader处理。

- 客户端的请求到达leader，leader将会记录日志，但是未提交给状态机
- leader将信息发给follower，follower收到请求之后返回确认信息给leader
- leader接收到半数以上的请求之后提交更新（应用到状态机中，得到输出），给客户端做出响应，然后发送请求给follower让它们也提交更新

网络分区故障

<img src="C:\Users\zsh\AppData\Roaming\Typora\typora-user-images\image-20210325191614711.png" alt="image-20210325191614711" style="zoom: 50%;" />

如果集群遭遇网络分区故障，划分为两个分区，节点B是原来的leader，节点C会成为新的leader，如果此时客户端的请求

- 打在了B上，那么B记录日志之后将消息发送给follower，但是发现没有收到半数的响应，所以这两个节点将不会提交更新
- 打在了C上，上半分区还是能够正常进行日志复制操作

当网络分区故障解除，leader B发现Term更高的leader，于是自己变成follower，回滚之前未提交的操作，并同步日志，保持与leader的数据一致性。

分布式事务的问题

分布式事务中如何保证事务不被重复提交？假如客户端发送一个事务到服务器，客户端在发出commit之后网络断掉了，客户端应该怎么操作确保事务已经提交了

- 可以确保提交的事务操作是幂等的，将记录做成一个唯一索引
- 使用分布式锁

如何保证事务方法的幂等

1 insert方法:数据库使用唯一索引，保证不重复插入数据

2 update方法:并发不大:使用乐观锁(版本号)，或者使用状态机。

3 select方法:天然就支持幂等，多次查询对数据不造成影响。

4 delete方法:一次删除和多次删除的结果对系统数据不影响。

## Raft和Zab的区别？

官方文档看：

zk提供的是非强一致性, 而是顺序一致性, 最终一致性;
raft提供的是强一致性, 因为client只能连leader节点~ 而leader本身拥有最新的数据
但是只连leader会不会读写能力很低, 所以应该可以根据业务的场景做定制化;
而zk和raft自身数据是强一致性的;